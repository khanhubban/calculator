package com.example.claculator_jav;

import android.os.Handler;
import android.os.Looper;
import androidx.lifecycle.LiveData;
import androidx.lifecycle.MutableLiveData;
import androidx.lifecycle.ViewModel;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class CalculatorViewModel extends ViewModel {

    // --- LiveData for UI Display ---
    private final MutableLiveData<String> _displayValue = new MutableLiveData<>("0");
    public final LiveData<String> displayValue = _displayValue;
    private final MutableLiveData<String> _secondaryDisplayValue = new MutableLiveData<>("");
    public final LiveData<String> secondaryDisplayValue = _secondaryDisplayValue;

    // --- LiveData for Calculation History ---
    private final MutableLiveData<List<String>> _history = new MutableLiveData<>(new ArrayList<>());
    public final LiveData<List<String>> history = _history;
    private final List<String> internalHistoryList = new ArrayList<>(); // Internal list for history management

    // --- Core Calculation Logic ---
    private final CalculatorEngine engine = new CalculatorEngine();

    // --- Infrastructure for Background Execution ---
    private final ExecutorService executor = Executors.newSingleThreadExecutor(); // Executes engine tasks off the main thread
    private final Handler mainThreadHandler = new Handler(Looper.getMainLooper()); // Posts results back to the main thread

    /**
     * Data class to hold the results (display strings) generated by a background task.
     * This prevents accessing the engine directly from the main thread for UI updates.
     */
    private static class DisplayUpdate {
        final String mainDisplay;
        final String secondaryDisplay;
        final boolean isInError;
        // Add the expression used for history logging
        final String expressionForHistory;

        DisplayUpdate(String main, String secondary, boolean error, String expression) {
            this.mainDisplay = main;
            this.secondaryDisplay = secondary;
            this.isInError = error;
            this.expressionForHistory = expression; // Store the expression
        }
    }

    // --- Public Methods (Called by Activity/Fragment) ---

    /** Processes a digit input ("0"-"9") on a background thread. */
    public void processDigit(String digit) {
        executor.execute(() -> {
            engine.inputDigit(digit);
            DisplayUpdate update = generateDisplayUpdate(); // Generate display state in background
            postUpdateToMainThread(update); // Post result to main thread
        });
    }

    /** Processes an operator input (+, -, ร, รท) on a background thread. */
    public void processOperator(String operator) {
        executor.execute(() -> {
            engine.inputOperator(operator);
            DisplayUpdate update = generateDisplayUpdate();
            postUpdateToMainThread(update);
        });
    }

    /** Processes a decimal point input on a background thread. */
    public void processDecimal() {
        executor.execute(() -> {
            engine.inputDecimal();
            DisplayUpdate update = generateDisplayUpdate();
            postUpdateToMainThread(update);
        });
    }

    /** Calculates the final result (=) on a background thread. */
    public void processEquals() {
        executor.execute(() -> {
            // Capture expression state *before* final calculation
            String expressionBeforeCalc = engine.getExpressionPreview(); // Get the full expression preview
            engine.calculateResult();
            String resultString = engine.getDisplayValue(); // Get the result string ("Error" if error)
            boolean errorState = engine.isInErrorState();

            // Determine final secondary display based on error state
            String finalSecondaryDisplay = !errorState ? "" : ""; // Clear secondary display after '='

            // Package results for main thread update, including the expression for history
            DisplayUpdate update = new DisplayUpdate(resultString, finalSecondaryDisplay, errorState, expressionBeforeCalc);

            // Post the specific result and final expression to the main thread
            mainThreadHandler.post(() -> {
                _displayValue.setValue(update.mainDisplay);
                _secondaryDisplayValue.setValue(update.secondaryDisplay);

                // *** START HISTORY LOGGING FIX ***
                // Add to history only if it wasn't an error and the expression is not empty
                if (!update.isInError && update.expressionForHistory != null && !update.expressionForHistory.trim().isEmpty()) {
                    // Check if the result is different from the expression (avoid logging "5 = 5")
                    // This check might need adjustment based on desired behavior for simple number entries
                    if (!update.expressionForHistory.equals(update.mainDisplay)) {
                        String historyEntry = update.expressionForHistory + " = " + update.mainDisplay;
                        internalHistoryList.add(historyEntry);
                        // Post a new list to LiveData to trigger observers
                        _history.setValue(new ArrayList<>(internalHistoryList));
                        System.out.println("ViewModel: Added to history: " + historyEntry); // Debugging
                    }
                } else if(update.isInError) {
                    System.out.println("ViewModel: Calculation resulted in error, not adding to history."); // Debugging
                }
                // *** END HISTORY LOGGING FIX ***
            });
        });
    }


    /** Processes parenthesis input ("(" or ")") on a background thread. */
    public void processParenthesis(String parenthesis) {
        executor.execute(() -> {
            // Parenthesis validity logic should primarily reside in CalculatorEngine
            engine.inputParenthesis(parenthesis);
            DisplayUpdate update = generateDisplayUpdate();
            postUpdateToMainThread(update);
        });
    }

    /** Processes the clear (AC) action on a background thread. */
    public void processClear() {
        executor.execute(() -> {
            engine.clear();
            DisplayUpdate update = generateDisplayUpdate(); // Get state after clear
            postUpdateToMainThread(update);
        });
    }

    /** Processes the backspace action on a background thread. */
    public void processBackspace() {
        executor.execute(() -> {
            engine.backspace();
            DisplayUpdate update = generateDisplayUpdate();
            postUpdateToMainThread(update);
        });
    }

    /** Processes the percentage (%) action on a background thread. */
    public void processPercentage() {
        executor.execute(() -> {
            engine.calculatePercentage();
            DisplayUpdate update = generateDisplayUpdate();
            postUpdateToMainThread(update);
        });
    }

    // --- Private Helper Methods ---

    /**
     * Generates the current display state by querying the engine.
     * IMPORTANT: This method runs on the background thread via the executor.
     * @return A DisplayUpdate object containing strings for the UI.
     */
    private DisplayUpdate generateDisplayUpdate() {
        String currentDisplay = engine.getDisplayValue();
        String expressionPreview = engine.getExpressionPreview();
        boolean errorState = engine.isInErrorState();

        // Determine if the secondary display should show the expression preview
        // Keep showing preview unless there's an error or after hitting equals (handled in processEquals)
        boolean showPreview = !expressionPreview.isEmpty() && !errorState;


        String finalSecondary = showPreview ? expressionPreview : "";

        // Pass the expression preview in the update object for potential history logging
        return new DisplayUpdate(currentDisplay, finalSecondary, errorState, expressionPreview);
    }


    /**
     * Posts the calculated display state back to the main thread to update LiveData.
     * @param update The DisplayUpdate object containing the state to display.
     */
    private void postUpdateToMainThread(DisplayUpdate update) {
        mainThreadHandler.post(() -> {
            // Update LiveData (must happen on main thread)
            _displayValue.setValue(update.mainDisplay);
            _secondaryDisplayValue.setValue(update.secondaryDisplay);
        });
    }

    /** Formats BigDecimal for display. */
    private String formatBigDecimal(BigDecimal value) {
        if (value == null) return "";
        // TODO: Add scientific notation handling if needed
        return value.stripTrailingZeros().toPlainString();
    }


    // --- History Methods ---

    /** Clears the calculation history. */
    public void clearHistory() {
        // Note: Ensure thread safety if history could be modified from multiple threads.
        // As operations are posted via Handler, this should be safe currently.
        internalHistoryList.clear();
        _history.setValue(new ArrayList<>(internalHistoryList)); // Update LiveData with a new empty list
        System.out.println("ViewModel: Cleared History");
    }

    // --- ViewModel Lifecycle ---

    public CalculatorViewModel() {
        // Post the initial display state update when ViewModel is created
        executor.execute(() -> {
            DisplayUpdate update = generateDisplayUpdate();
            postUpdateToMainThread(update);
        });
    }

    /** Cleans up resources, like shutting down the background thread executor. */
    @Override
    protected void onCleared() {
        super.onCleared();
        executor.shutdown(); // Ensure background thread pool is released
        System.out.println("ViewModel: Executor shutdown.");
    }
}